<!DOCTYPE html>
<html>

<head>
    <title>Gemini 3: Ultra 3D Shapes</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            z-index: 10;
            pointer-events: none;
        }

        #mode {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 2em;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        video {
            display: none;
        }
    </style>
</head>

<body>
    <div id="ui"><b>[ SYSTEM ACTIVE ]</b><br>MOVE HAND LEFT/RIGHT TO MORPH<br>PINCH TO TRIGGER EXPLOSION</div>
    <div id="mode">Initializing...</div>
    <video id="video" playsinline></video>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        let scene, camera, renderer, particles, handLandmarker;
        let video = document.getElementById('video');
        const particleCount = 10000;

        // Target buffers for morphing
        const currentPos = new Float32Array(particleCount * 3);
        const targetPos = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geo = new THREE.BufferGeometry();
            const cols = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                currentPos[i * 3] = (Math.random() - 0.5) * 20;
                currentPos[i * 3 + 1] = (Math.random() - 0.5) * 20;
                currentPos[i * 3 + 2] = (Math.random() - 0.5) * 20;
                cols[i * 3] = Math.random();
                cols[i * 3 + 1] = Math.random();
                cols[i * 3 + 2] = 1.0;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));

            const mat = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO"
            });

            startCamera();
        }

        function setShape(type) {
            document.getElementById('mode').innerText = type;
            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                const i3 = i * 3;

                if (type === "JUPITER") {
                    const phi = Math.acos(-1 + (2 * i) / particleCount);
                    const theta = Math.sqrt(particleCount * Math.PI) * phi;
                    x = 4 * Math.cos(theta) * Math.sin(phi);
                    y = 4 * Math.sin(theta) * Math.sin(phi);
                    z = 4 * Math.cos(phi);
                    // Add bands
                    if (Math.abs(y) < 0.5 || Math.abs(y) > 2) x *= 1.1, z *= 1.1;
                } else if (type === "HEART") {
                    const t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3) / 4;
                    y = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 4;
                    z = (Math.random() - 0.5) * 2;
                } else if (type === "SATURN") {
                    if (i < particleCount * 0.4) { // Planet
                        const r = 3;
                        const u = Math.random(); const v = Math.random();
                        const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else { // Rings
                        const r = 5 + Math.random() * 3;
                        const theta = Math.random() * Math.PI * 2;
                        x = r * Math.cos(theta); y = (Math.random() - 0.5) * 0.2; z = r * Math.sin(theta);
                    }
                } else { // FIREWORKS (Random Burst)
                    x = (Math.random() - 0.5) * 15; y = (Math.random() - 0.5) * 15; z = (Math.random() - 0.5) * 15;
                }
                targetPos[i3] = x; targetPos[i3 + 1] = y; targetPos[i3 + 2] = z;
            }
        }

        async function startCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.play();
            video.addEventListener('loadeddata', animate);
        }

        function animate() {
            requestAnimationFrame(animate);
            let results = handLandmarker.detectForVideo(video, performance.now());
            const pos = particles.geometry.attributes.position.array;

            if (results.landmarks && results.landmarks.length > 0) {
                const hand = results.landmarks[0];
                const xPos = hand[8].x;

                // Switch Mode by X position
                if (xPos < 0.25) setShape("JUPITER");
                else if (xPos < 0.5) setShape("SATURN");
                else if (xPos < 0.75) setShape("HEART");
                else setShape("FIREWORKS");

                // Smoothly Lerp to target
                for (let i = 0; i < pos.length; i++) {
                    pos[i] += (targetPos[i] - pos[i]) * 0.05;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }

            particles.rotation.y += 0.005;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>