<!DOCTYPE html>
<html>

<head>
    <title>Gemini 3: Dual-Hand Master Controller</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border: 2px solid #333;
            box-sizing: border-box;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00f2ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            line-height: 1.6;
        }

        #status {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 0 0 20px #00f2ff;
        }

        video {
            display: none;
        }
    </style>
</head>

<body>
    <div id="overlay"></div>
    <div id="ui">
        <b>Tracking:</b> 2 Hands Active<br>
        <b>Pinch Width:</b> <span id="pinch-val">0.0</span><br>
        <b>Current Mode:</b> <span id="mode-text">Syncing...</span>
    </div>
    <div id="status">WAVE TWO HANDS</div>
    <video id="video" playsinline></video>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        let scene, camera, renderer, particles, handLandmarker;
        let video = document.getElementById('video');
        const particleCount = 15000;

        const currentPos = new Float32Array(particleCount * 3);
        const targetPos = new Float32Array(particleCount * 3);

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15; // Zoomed out for larger shapes

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geo = new THREE.BufferGeometry();
            const cols = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                currentPos[i * 3] = (Math.random() - 0.5) * 30;
                currentPos[i * 3 + 1] = (Math.random() - 0.5) * 30;
                currentPos[i * 3 + 2] = (Math.random() - 0.5) * 30;
                cols[i * 3] = 0.5; cols[i * 3 + 1] = 0.8; cols[i * 3 + 2] = 1.0;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));

            const mat = new THREE.PointsMaterial({ size: 0.06, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.7 });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });

            startCamera();
        }

        function updateShape(mode, expansion) {
            document.getElementById('mode-text').innerText = mode;
            document.getElementById('status').innerText = mode;
            const scale = 5 + (expansion * 15); // Large scale multiplier

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                const i3 = i * 3;

                if (mode === "JUPITER") {
                    const phi = Math.acos(-1 + (2 * i) / particleCount);
                    const theta = Math.sqrt(particleCount * Math.PI) * phi;
                    x = scale * Math.cos(theta) * Math.sin(phi);
                    y = scale * Math.sin(theta) * Math.sin(phi);
                    z = scale * Math.cos(phi);
                    if (Math.abs(y) < scale * 0.1) { x *= 1.5; z *= 1.5; } // Jupiter bands logic
                } else if (mode === "HEART") {
                    const t = Math.random() * Math.PI * 2;
                    const r = scale * 0.6;
                    x = r * 16 * Math.pow(Math.sin(t), 3) / 16;
                    y = r * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 16;
                    z = (Math.random() - 0.5) * (scale * 0.2);
                } else if (mode === "SATURN") {
                    if (i < particleCount * 0.5) { // Planet
                        const r = scale * 0.5;
                        const u = Math.random(); const v = Math.random();
                        const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else { // Huge Rings
                        const r = (scale * 0.8) + Math.random() * (scale * 0.6);
                        const theta = Math.random() * Math.PI * 2;
                        x = r * Math.cos(theta); y = (Math.random() - 0.5) * 0.2; z = r * Math.sin(theta);
                    }
                } else { // FIREWORKS
                    const r = scale * (Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                targetPos[i3] = x; targetPos[i3 + 1] = y; targetPos[i3 + 2] = z;
            }
        }

        async function startCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.play();
            video.addEventListener('loadeddata', animate);
        }

        function animate() {
            requestAnimationFrame(animate);
            let results = handLandmarker.detectForVideo(video, performance.now());
            const pos = particles.geometry.attributes.position.array;

            if (results.landmarks && results.landmarks.length > 0) {
                const hands = results.landmarks;

                // 1. Calculate Hand-to-Hand Distance (Expansion)
                let expansion = 0.5;
                if (hands.length === 2) {
                    const d = Math.hypot(hands[0][0].x - hands[1][0].x, hands[0][0].y - hands[1][0].y);
                    expansion = d;
                    document.getElementById('pinch-val').innerText = d.toFixed(2);
                } else {
                    // Single hand pinch fallback
                    const pinch = Math.hypot(hands[0][8].x - hands[0][4].x, hands[0][8].y - hands[0][4].y);
                    expansion = pinch * 2;
                }

                // 2. Determine Mode based on Right Hand (or only hand) X position
                const controlHand = hands.length === 2 ? hands[1] : hands[0];
                const xPos = controlHand[0].x;
                let mode = "FIREWORKS";
                if (xPos < 0.25) mode = "JUPITER";
                else if (xPos < 0.5) mode = "SATURN";
                else if (xPos < 0.75) mode = "HEART";

                updateShape(mode, expansion);

                // 3. Color Logic via Left Hand height
                const colorHand = hands.length === 2 ? hands[0] : hands[0];
                particles.material.color.setHSL(1 - colorHand[0].y, 0.8, 0.6);

                // Morphing Animation
                for (let i = 0; i < pos.length; i++) {
                    pos[i] += (targetPos[i] - pos[i]) * 0.1;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }

            particles.rotation.y += 0.003;
            renderer.render(scene, camera);
        }

        init();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>